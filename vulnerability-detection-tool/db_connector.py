# db_connector.py - Fixed with transaction handling
import psycopg2
from psycopg2.extras import RealDictCursor
import json
from typing import List, Dict, Optional, Tuple
from vector_service import VectorService

class CVEDatabase:
    """Database interface for CVE/CWE queries"""

    def __init__(self):
        self.config = {
            'host': 'foss-cherub-db',
            'port': 5432,
            'database': 'foss_cherub',
            'user': 'postgres',
            'password': 'fosscherub'
        }
        self.conn = None
        self.vector_service = VectorService()
        self.connect()

    def connect(self):
        try:
            self.conn = psycopg2.connect(**self.config)
            self.conn.autocommit = True  # Enable autocommit for read queries
            print("‚úÖ Connected to PostgreSQL database")
        except Exception as e:
            print(f"‚ùå Database connection failed: {e}")
            raise

    def _reset_connection(self):
        """Reset connection on transaction error"""
        try:
            self.conn.rollback()
        except:
            try:
                self.conn.close()
            except:
                pass
            self.connect()

    def get_cwe_details(self, cwe_id: str) -> Optional[Dict]:
        """Get detailed CWE information"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT cwe_id, name, description, typical_severity, 
                           potential_mitigations, created_at
                    FROM cwe WHERE cwe_id = %s
                """, (cwe_id,))
                result = cursor.fetchone()
                return dict(result) if result else None
        except Exception as e:
            self._reset_connection()
            return None

    def search_cves_by_cwe(self, cwe_id: str, limit=10) -> List[Dict]:
        """Find CVEs associated with a CWE"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT cve_id, description, cvss_base_score, cvss_base_severity,
                           cvss_vector_string, published_date
                    FROM cve
                    WHERE %s = ANY(cwe_ids)
                    ORDER BY cvss_base_score DESC, published_date DESC
                    LIMIT %s
                """, (cwe_id, limit))
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []

    def save_scan_result(self, repo_url: str, findings: List[Dict], detection_score: Dict) -> str:
        """Save scan results to database"""
        # Temporarily disable autocommit for transaction
        self.conn.autocommit = False
        try:
            cursor = self.conn.cursor()

            severity_counts = {
                'critical': sum(1 for f in findings if f.get('Severity') == 'CRITICAL'),
                'high': sum(1 for f in findings if f.get('Severity') == 'HIGH'),
                'medium': sum(1 for f in findings if f.get('Severity') == 'MEDIUM'),
                'low': sum(1 for f in findings if f.get('Severity') == 'LOW')
            }

            cursor.execute("""
                INSERT INTO scan_results 
                (repository_url, total_findings, critical_count, high_count, 
                 medium_count, low_count, detection_score)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
                RETURNING scan_id
            """, (
                repo_url,
                len(findings),
                severity_counts['critical'],
                severity_counts['high'],
                severity_counts['medium'],
                severity_counts['low'],
                json.dumps(detection_score)
            ))

            scan_id = cursor.fetchone()[0]

            for finding in findings:
                cwe_id = finding.get('CWE', '').split(',')[0].strip()
                if not cwe_id.startswith('CWE-'):
                    cwe_id = None

                # Generate embeddings
                desc_text = self.vector_service.prepare_vulnerability_text({
                    'vulnerability_description': finding.get('Vulnerability'),
                    'cwe_id': cwe_id,
                    'severity': finding.get('Severity'),
                    'file_path': finding.get('File Path')
                })
                code_text = self.vector_service.prepare_code_text({
                    'ast_analysis': finding.get('ast_analysis', {}),
                    'file_path': finding.get('File Path'),
                    'line_number': finding.get('Line')
                })
                
                desc_embedding = self.vector_service.generate_embedding(desc_text)
                code_embedding = self.vector_service.generate_embedding(code_text)

                cursor.execute("""
                    INSERT INTO findings 
                    (scan_id, source, file_path, line_number, vulnerability_description, 
                     severity, cwe_id, zero_day_risk, description_embedding, code_embedding)
                    VALUES (%s, %s, %s, %s, %s, %s, %s, %s, %s, %s)
                """, (
                    scan_id,
                    finding.get('Source'),
                    finding.get('File Path'),
                    finding.get('Line'),
                    finding.get('Vulnerability'),
                    finding.get('Severity'),
                    cwe_id,
                    finding.get('Zero-Day Risk'),
                    desc_embedding,
                    code_embedding
                ))

            self.conn.commit()
            cursor.close()
            return str(scan_id)
        except Exception as e:
            self.conn.rollback()
            raise
        finally:
            self.conn.autocommit = True

    def get_scan_history(self, limit=20) -> List[Dict]:
        """Get recent scan history"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT scan_id, repository_url, scan_date, total_findings,
                           critical_count, high_count, medium_count, low_count,
                           detection_score
                    FROM scan_results
                    ORDER BY scan_date DESC
                    LIMIT %s
                """, (limit,))
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []

    def get_findings_by_scan(self, scan_id: str) -> List[Dict]:
        """Get all findings for a specific scan"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT * FROM findings 
                    WHERE scan_id = %s 
                    ORDER BY severity, file_path
                """, (scan_id,))
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []

    def get_vulnerability_statistics(self) -> List[Dict]:
        """Get vulnerability statistics"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT 
                        f.cwe_id,
                        c.name as cwe_name,
                        c.typical_severity,
                        COUNT(*) as occurrence_count,
                        COUNT(DISTINCT f.scan_id) as affected_scans
                    FROM findings f
                    LEFT JOIN cwe c ON f.cwe_id = c.cwe_id
                    WHERE f.cwe_id IS NOT NULL
                    GROUP BY f.cwe_id, c.name, c.typical_severity
                    ORDER BY occurrence_count DESC
                    LIMIT 20
                """)
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []

    def get_statistics(self) -> Dict:
        """Get overall database statistics"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                stats = {}

                cursor.execute("SELECT COUNT(*) as count FROM cwe")
                stats['cwe_count'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM cve")
                stats['cve_count'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM scan_results")
                stats['scans_count'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM findings")
                stats['total_findings'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM findings WHERE resolved = FALSE")
                stats['open_findings'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM findings WHERE resolved = TRUE")
                stats['resolved_findings'] = cursor.fetchone()['count']

                cursor.execute("SELECT COUNT(*) as count FROM findings WHERE false_positive = TRUE")
                stats['false_positives'] = cursor.fetchone()['count']

                cursor.execute("""
                    SELECT severity, COUNT(*) as count 
                    FROM findings 
                    WHERE resolved = FALSE
                    GROUP BY severity
                """)
                stats['by_severity'] = {row['severity']: row['count'] for row in cursor.fetchall()}

                return stats
        except Exception as e:
            self._reset_connection()
            return {
                'cwe_count': 0, 'cve_count': 0, 'scans_count': 0,
                'total_findings': 0, 'open_findings': 0,
                'resolved_findings': 0, 'false_positives': 0,
                'by_severity': {}
            }

    def test_connection(self) -> bool:
        """Test database connection"""
        try:
            stats = self.get_statistics()

            print()
            print("=" * 70)
            print("DATABASE STATISTICS")
            print("=" * 70)
            print(f"CWE Entries:        {stats['cwe_count']:,}")
            print(f"CVE Entries:        {stats['cve_count']:,}")
            print(f"Scans Recorded:     {stats['scans_count']:,}")
            print(f"Total Findings:     {stats['total_findings']:,}")
            print(f"Open Findings:      {stats['open_findings']:,}")
            print(f"Resolved Findings:  {stats['resolved_findings']:,}")
            print(f"False Positives:    {stats['false_positives']:,}")

            if stats['by_severity']:
                print()
                print("Findings by Severity:")
                for severity, count in stats['by_severity'].items():
                    print(f"  {severity:10s}: {count:,}")

            print("=" * 70)
            return True
        except Exception as e:
            print(f"‚ùå Test failed: {e}")
            return False

    def find_similar_vulnerabilities(self, query_text: str, limit: int = 10, similarity_threshold: float = 0.7) -> List[Dict]:
        """Find similar vulnerabilities using vector similarity search"""
        try:
            query_embedding = self.vector_service.generate_embedding(query_text)
            
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT f.*, 
                           (1 - (description_embedding <=> %s)) as similarity_score,
                           c.name as cwe_name
                    FROM findings f
                    LEFT JOIN cwe c ON f.cwe_id = c.cwe_id
                    WHERE f.description_embedding IS NOT NULL
                      AND (1 - (description_embedding <=> %s)) > %s
                    ORDER BY description_embedding <=> %s
                    LIMIT %s
                """, (query_embedding, query_embedding, similarity_threshold, query_embedding, limit))
                
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []
    
    def find_similar_code_patterns(self, code_snippet: str, limit: int = 10, similarity_threshold: float = 0.7) -> List[Dict]:
        """Find similar code patterns using vector similarity search"""
        try:
            code_embedding = self.vector_service.generate_embedding(code_snippet)
            
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    SELECT f.*, 
                           (1 - (code_embedding <=> %s)) as similarity_score,
                           c.name as cwe_name
                    FROM findings f
                    LEFT JOIN cwe c ON f.cwe_id = c.cwe_id
                    WHERE f.code_embedding IS NOT NULL
                      AND (1 - (code_embedding <=> %s)) > %s
                    ORDER BY code_embedding <=> %s
                    LIMIT %s
                """, (code_embedding, code_embedding, similarity_threshold, code_embedding, limit))
                
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []
    
    def get_vulnerability_clusters(self, min_cluster_size: int = 3) -> List[Dict]:
        """Get vulnerability clusters based on similarity"""
        try:
            with self.conn.cursor(cursor_factory=RealDictCursor) as cursor:
                cursor.execute("""
                    WITH similarity_pairs AS (
                        SELECT 
                            f1.id as id1,
                            f2.id as id2,
                            f1.vulnerability_description as desc1,
                            f2.vulnerability_description as desc2,
                            f1.cwe_id,
                            (1 - (f1.description_embedding <=> f2.description_embedding)) as similarity
                        FROM findings f1
                        JOIN findings f2 ON f1.id < f2.id
                        WHERE f1.description_embedding IS NOT NULL 
                          AND f2.description_embedding IS NOT NULL
                          AND (1 - (f1.description_embedding <=> f2.description_embedding)) > 0.8
                    )
                    SELECT 
                        cwe_id,
                        COUNT(*) as cluster_size,
                        AVG(similarity) as avg_similarity,
                        ARRAY_AGG(DISTINCT desc1) as sample_descriptions
                    FROM similarity_pairs
                    GROUP BY cwe_id
                    HAVING COUNT(*) >= %s
                    ORDER BY cluster_size DESC
                """, (min_cluster_size,))
                
                results = cursor.fetchall()
                return [dict(row) for row in results]
        except Exception as e:
            self._reset_connection()
            return []

    def close(self):
        """Close database connection"""
        if self.conn:
            self.conn.close()
            print("Database connection closed")

if __name__ == "__main__":
    print("Testing CVE Database Connector...")
    print("=" * 70)

    try:
        db = CVEDatabase()
        db.test_connection()

        print()
        print("üîç Testing CWE Lookup:")
        print("-" * 70)
        cwe = db.get_cwe_details('CWE-89')
        if cwe:
            print(f"  CWE ID:      {cwe['cwe_id']}")
            print(f"  Name:        {cwe['name']}")
            print(f"  Severity:    {cwe['typical_severity']}")
            print(f"  Description: {cwe['description'][:100]}...")

        print()
        print("üìä Recent Scan History:")
        print("-" * 70)
        scans = db.get_scan_history(limit=5)
        if scans:
            for scan in scans:
                print(f"  {scan['scan_date']} - {scan['repository_url']}")
                print(f"    Findings: {scan['total_findings']} (C:{scan['critical_count']} H:{scan['high_count']})")
        else:
            print("  No scans recorded yet")

        db.close()

        print()
        print("=" * 70)
        print("‚úÖ Database connector working perfectly!")
        print("=" * 70)

    except Exception as e:
        print(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()
