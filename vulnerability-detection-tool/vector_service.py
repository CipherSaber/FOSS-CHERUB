"""Vector embedding service for similarity search"""
import numpy as np
from sentence_transformers import SentenceTransformer
from typing import List, Dict, Optional, Tuple
import logging

logger = logging.getLogger(__name__)

class VectorService:
    """Service for generating embeddings and performing similarity search"""
    
    def __init__(self, model_name: str = "all-MiniLM-L6-v2"):
        """Initialize with sentence transformer model"""
        self.model = SentenceTransformer(model_name)
        self.embedding_dim = 384  # Dimension for all-MiniLM-L6-v2
        
    def generate_embedding(self, text: str) -> List[float]:
        """Generate embedding for text"""
        if not text or not text.strip():
            return [0.0] * self.embedding_dim
        
        try:
            embedding = self.model.encode(text, normalize_embeddings=True)
            return embedding.tolist()
        except Exception as e:
            logger.error(f"Error generating embedding: {e}")
            return [0.0] * self.embedding_dim
    
    def generate_batch_embeddings(self, texts: List[str]) -> List[List[float]]:
        """Generate embeddings for multiple texts"""
        if not texts:
            return []
        
        # Filter empty texts
        valid_texts = [text if text and text.strip() else " " for text in texts]
        
        try:
            embeddings = self.model.encode(valid_texts, normalize_embeddings=True)
            return embeddings.tolist()
        except Exception as e:
            logger.error(f"Error generating batch embeddings: {e}")
            return [[0.0] * self.embedding_dim] * len(texts)
    
    def cosine_similarity(self, vec1: List[float], vec2: List[float]) -> float:
        """Calculate cosine similarity between two vectors"""
        try:
            a = np.array(vec1)
            b = np.array(vec2)
            return float(np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b)))
        except:
            return 0.0
    
    def prepare_vulnerability_text(self, finding: Dict) -> str:
        """Prepare vulnerability description for embedding"""
        parts = []
        
        if finding.get('vulnerability_description'):
            parts.append(finding['vulnerability_description'])
        
        if finding.get('cwe_id'):
            parts.append(f"CWE: {finding['cwe_id']}")
        
        if finding.get('severity'):
            parts.append(f"Severity: {finding['severity']}")
        
        if finding.get('file_path'):
            # Extract file extension for context
            ext = finding['file_path'].split('.')[-1] if '.' in finding['file_path'] else ''
            if ext:
                parts.append(f"Language: {ext}")
        
        return " | ".join(parts)
    
    def prepare_code_text(self, finding: Dict) -> str:
        """Prepare code snippet for embedding"""
        parts = []
        
        if finding.get('ast_analysis') and isinstance(finding['ast_analysis'], dict):
            if finding['ast_analysis'].get('code_snippet'):
                parts.append(finding['ast_analysis']['code_snippet'])
        
        if finding.get('file_path'):
            parts.append(f"File: {finding['file_path']}")
        
        if finding.get('line_number'):
            parts.append(f"Line: {finding['line_number']}")
        
        return " | ".join(parts) if parts else ""