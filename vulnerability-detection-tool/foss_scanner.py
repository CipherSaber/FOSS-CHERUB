#!/usr/bin/env python3

import os
import json
import subprocess
import shutil
import re
import ast
import argparse
from pathlib import Path
from typing import List, Dict, Any, Optional

import pandas as pd
from datetime import datetime
import logging

import torch
from transformers import AutoTokenizer, AutoModelForCausalLM
import psycopg2
from psycopg2.extras import RealDictCursor


# ----------------------------------------------------------------------
# Logging
# ----------------------------------------------------------------------
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s - %(levelname)s - %(message)s",
)
logger = logging.getLogger(__name__)


# ----------------------------------------------------------------------
# Multi-language Taint Tracker
# ----------------------------------------------------------------------
class MultiLanguageTaintTracker:
    """
    AST-based taint analysis for Python, JavaScript, Java, C/C++.
    Tracks data flow from sources (user input) to sinks (dangerous functions).
    """
    
    def __init__(self):
        self.init_tree_sitter()
        
    def init_tree_sitter(self):
        """Initialize tree-sitter parsers for multiple languages."""
        try:
            from tree_sitter import Language, Parser
            import tree_sitter_python as tspython
            import tree_sitter_javascript as tsjs
            import tree_sitter_java as tsjava
            import tree_sitter_c as tsc
            import tree_sitter_cpp as tscpp
            
            self.parsers = {
                'python': Parser(Language(tspython.language())),
                'javascript': Parser(Language(tsjs.language())),
                'java': Parser(Language(tsjava.language())),
                'c': Parser(Language(tsc.language())),
                'cpp': Parser(Language(tscpp.language())),
            }
            self.tree_sitter_available = True
            logger.info("Tree-sitter parsers loaded for multi-language taint tracking")
        except ImportError:
            self.tree_sitter_available = False
            logger.warning("Tree-sitter not available - falling back to Python AST only")
    
    def get_language_key(self, file_path: str) -> Optional[str]:
        """Map file extension to parser key."""
        ext = Path(file_path).suffix.lower()
        mapping = {
            '.py': 'python',
            '.js': 'javascript', '.jsx': 'javascript', '.ts': 'javascript', '.tsx': 'javascript',
            '.java': 'java',
            '.c': 'c', '.h': 'c',
            '.cpp': 'cpp', '.cc': 'cpp', '.cxx': 'cpp', '.hpp': 'cpp', '.hxx': 'cpp',
        }
        return mapping.get(ext)
    
    def analyze_file(self, file_path: str, line_number: int) -> Dict[str, Any]:
        """
        Run taint analysis on a file at a specific line.
        Returns: {'is_tainted': bool, 'flow': str, 'confidence': str}
        """
        lang_key = self.get_language_key(file_path)
        
        # Python: use AST module (most accurate)
        if lang_key == 'python' and file_path.endswith('.py'):
            return self._analyze_python_ast(file_path, line_number)
        
        # Other languages: use tree-sitter
        if self.tree_sitter_available and lang_key in self.parsers:
            return self._analyze_with_tree_sitter(file_path, line_number, lang_key)
        
        return {'is_tainted': None, 'flow': 'Language not supported for taint analysis', 'confidence': 'low'}
    
    # ------------------------------------------------------------------
    # Python AST Taint Tracking
    # ------------------------------------------------------------------
    def _analyze_python_ast(self, file_path: str, line_number: int) -> Dict[str, Any]:
        """High-precision Python taint tracking using AST."""
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                source = f.read()
            tree = ast.parse(source)
        except Exception as e:
            return {'is_tainted': None, 'flow': f'Parse error: {e}', 'confidence': 'low'}

        TAINT_SOURCES = {
            'request.args', 'request.form', 'request.GET', 'request.POST',
            'request.json', 'request.data', 'request.cookies',
            'input', 'os.environ', 'sys.argv', 'open',
        }
        TAINT_SINKS = {
            'eval', 'exec', 'compile', '__import__',
            'os.system', 'subprocess.run', 'subprocess.call', 'subprocess.Popen',
            'cursor.execute', 'conn.execute', 'execute',
            'pickle.loads', 'yaml.load',
        }

        class TaintTracker(ast.NodeVisitor):
            def __init__(self, target_line):
                self.target_line = target_line
                self.tainted_vars = set()
                self.flow_path = []
                self.is_dangerous = False

            def visit_Assign(self, node):
                """Track variable assignments."""
                for source in TAINT_SOURCES:
                    if self._contains_call(node.value, source):
                        for target in node.targets:
                            if isinstance(target, ast.Name):
                                self.tainted_vars.add(target.id)
                                self.flow_path.append(
                                    f"Line {node.lineno}: {target.id} ← {source}() [TAINT SOURCE]"
                                )
                
                # Propagate taint through assignments
                if isinstance(node.value, ast.Name) and node.value.id in self.tainted_vars:
                    for target in node.targets:
                        if isinstance(target, ast.Name):
                            self.tainted_vars.add(target.id)
                            self.flow_path.append(
                                f"Line {node.lineno}: {target.id} ← {node.value.id} [PROPAGATE]"
                            )
                
                self.generic_visit(node)

            def visit_Call(self, node):
                """Check if sink receives tainted data."""
                if node.lineno == self.target_line:
                    func_name = self._get_func_name(node.func)
                    if any(sink in func_name for sink in TAINT_SINKS):
                        # Check arguments
                        for arg in node.args:
                            if isinstance(arg, ast.Name) and arg.id in self.tainted_vars:
                                self.is_dangerous = True
                                self.flow_path.append(
                                    f"Line {node.lineno}: {func_name}({arg.id}) [TAINTED SINK] ❌"
                                )
                                return
                            # Check f-strings and formatted strings
                            if isinstance(arg, ast.JoinedStr):
                                for val in arg.values:
                                    if isinstance(val, ast.FormattedValue):
                                        if isinstance(val.value, ast.Name) and val.value.id in self.tainted_vars:
                                            self.is_dangerous = True
                                            self.flow_path.append(
                                                f"Line {node.lineno}: {func_name}(f-string with {val.value.id}) [TAINTED SINK] ❌"
                                            )
                                            return
                        
                        # Sink found but args are safe
                        self.flow_path.append(
                            f"Line {node.lineno}: {func_name}() [SINK - safe args] ✅"
                        )
                self.generic_visit(node)

            def _contains_call(self, node, pattern):
                """Check if node contains a call matching pattern."""
                if isinstance(node, ast.Call):
                    name = self._get_func_name(node.func)
                    return pattern in name
                for child in ast.walk(node):
                    if isinstance(child, ast.Call):
                        name = self._get_func_name(child.func)
                        if pattern in name:
                            return True
                return False

            def _get_func_name(self, node):
                """Extract function/method name."""
                if isinstance(node, ast.Name):
                    return node.id
                elif isinstance(node, ast.Attribute):
                    parts = []
                    current = node
                    while isinstance(current, ast.Attribute):
                        parts.append(current.attr)
                        current = current.value
                    if isinstance(current, ast.Name):
                        parts.append(current.id)
                    return '.'.join(reversed(parts))
                return ''

        tracker = TaintTracker(line_number)
        tracker.visit(tree)
        
        return {
            'is_tainted': tracker.is_dangerous,
            'flow': '\n'.join(tracker.flow_path) if tracker.flow_path else 'No taint path found',
            'tainted_vars': list(tracker.tainted_vars),
            'confidence': 'high' if tracker.flow_path else 'medium'
        }
    
    # ------------------------------------------------------------------
    # Tree-sitter Multi-language Taint Tracking
    # ------------------------------------------------------------------
    def _analyze_with_tree_sitter(self, file_path: str, line_number: int, lang_key: str) -> Dict[str, Any]:
        """
        Generic taint tracking using tree-sitter for JS/Java/C/C++.
        Less precise than AST but works across languages.
        """
        try:
            with open(file_path, 'rb') as f:
                code = f.read()
            
            parser = self.parsers[lang_key]
            tree = parser.parse(code)
            
            # Language-specific taint sources and sinks
            sources, sinks = self._get_lang_patterns(lang_key)
            
            # Find all function calls
            tainted_vars = set()
            flow_path = []
            is_dangerous = False
            
            def find_calls(node, depth=0):
                nonlocal is_dangerous
                
                if depth > 50:  # Prevent deep recursion
                    return
                
                # Check if this is a function call
                if node.type in ['call_expression', 'function_call', 'call']:
                    func_name = self._extract_function_name(node, code)
                    node_line = node.start_point[0] + 1
                    
                    # Is it a taint source?
                    if any(src in func_name for src in sources):
                        # Try to find variable assignment
                        parent = node.parent
                        if parent and parent.type in ['variable_declarator', 'assignment_expression', 'local_variable_declaration']:
                            var_name = self._extract_var_name(parent, code)
                            if var_name:
                                tainted_vars.add(var_name)
                                flow_path.append(f"Line {node_line}: {var_name} ← {func_name}() [SOURCE]")
                    
                    # Is it our target sink?
                    if node_line == line_number and any(sink in func_name for sink in sinks):
                        # Check if arguments are tainted
                        args_node = self._get_arguments_node(node)
                        if args_node:
                            for arg in args_node.children:
                                arg_text = code[arg.start_byte:arg.end_byte].decode('utf-8', errors='ignore')
                                if any(var in arg_text for var in tainted_vars):
                                    is_dangerous = True
                                    flow_path.append(f"Line {node_line}: {func_name}(tainted) [SINK] ❌")
                                    return
                        
                        flow_path.append(f"Line {node_line}: {func_name}() [SINK - safe] ✅")
                
                # Recurse
                for child in node.children:
                    find_calls(child, depth + 1)
            
            find_calls(tree.root_node)
            
            return {
                'is_tainted': is_dangerous,
                'flow': '\n'.join(flow_path) if flow_path else f'No taint flow found ({lang_key})',
                'confidence': 'medium'
            }
        
        except Exception as e:
            return {'is_tainted': None, 'flow': f'Tree-sitter error: {e}', 'confidence': 'low'}
    
    def _get_lang_patterns(self, lang_key: str):
        """Get taint sources and sinks per language."""
        patterns = {
            'javascript': (
                ['req.query', 'req.body', 'req.params', 'location.search', 'document.cookie', 'process.env'],
                ['eval', 'Function', 'setTimeout', 'setInterval', 'innerHTML', 'document.write', 'dangerouslySetInnerHTML']
            ),
            'java': (
                ['getParameter', 'getHeader', 'getCookies', 'getQueryString', 'System.getenv'],
                ['Runtime.exec', 'ProcessBuilder', 'eval', 'executeQuery', 'executeUpdate']
            ),
            'c': (
                ['getenv', 'fgets', 'gets', 'scanf', 'fscanf'],
                ['system', 'popen', 'exec', 'strcpy', 'sprintf', 'strcat']
            ),
            'cpp': (
                ['getenv', 'cin', 'fgets', 'gets'],
                ['system', 'popen', 'exec', 'strcpy', 'sprintf']
            ),
        }
        return patterns.get(lang_key, ([], []))
    
    def _extract_function_name(self, node, code: bytes) -> str:
        """Extract function name from call node."""
        for child in node.children:
            if child.type in ['identifier', 'member_expression', 'field_expression', 'method_invocation']:
                return code[child.start_byte:child.end_byte].decode('utf-8', errors='ignore')
        return ''
    
    def _extract_var_name(self, node, code: bytes) -> str:
        """Extract variable name from assignment/declaration."""
        for child in node.children:
            if child.type in ['identifier', 'variable_declarator']:
                text = code[child.start_byte:child.end_byte].decode('utf-8', errors='ignore')
                # Clean up (remove type info, etc.)
                return text.split('=')[0].strip().split()[-1]
        return ''
    
    def _get_arguments_node(self, call_node):
        """Find the arguments list node."""
        for child in call_node.children:
            if child.type in ['arguments', 'argument_list']:
                return child
        return None


# ----------------------------------------------------------------------
# Main Scanner Class
# ----------------------------------------------------------------------
class FOSSCHERUBScanner:
    """
    Enhanced scanner with multi-language taint tracking:
    - Semgrep taint mode (all languages)
    - AST-based taint tracking (Python/JS/Java/C/C++)
    - Qwen CWE classification
    - PostgreSQL CVE/CWE enrichment
    """

    def __init__(self, db_config: Dict[str, Any], model_path: str):
        self.db_config = db_config
        self.model_path = model_path

        logger.info("=" * 60)
        logger.info("FOSS-CHERUB Scanner v2.0 (Multi-language Taint Tracking)")
        logger.info("=" * 60)

        if not os.path.isdir(self.model_path):
            raise RuntimeError(f"Model path does not exist: {self.model_path}")

        self._init_database_connection()
        self._init_ai_model()
        self._init_mappings()
        self.taint_tracker = MultiLanguageTaintTracker()
        self._create_semgrep_taint_rules()

    def _create_semgrep_taint_rules(self):
        """Create custom taint-mode rules for Semgrep."""
        rules_content = """
rules:
  # Python taint rules
  - id: python-taint-sql-injection
    mode: taint
    pattern-sources:
      - pattern: request.args.get(...)
      - pattern: request.form.get(...)
      - pattern: request.GET[...]
      - pattern: request.POST[...]
      - pattern: input(...)
    pattern-sinks:
      - pattern: cursor.execute($QUERY)
      - pattern: conn.execute($QUERY)
      - pattern: $DB.execute($QUERY)
    message: SQL injection - user input flows to SQL execution
    languages: [python]
    severity: ERROR
    metadata:
      cwe: CWE-89
      
  - id: python-taint-command-injection
    mode: taint
    pattern-sources:
      - pattern: request.args.get(...)
      - pattern: os.environ.get(...)
      - pattern: sys.argv[...]
    pattern-sinks:
      - pattern: os.system($CMD)
      - pattern: subprocess.run($CMD, ...)
      - pattern: subprocess.call($CMD, ...)
    message: Command injection - tainted input to system command
    languages: [python]
    severity: ERROR
    metadata:
      cwe: CWE-78

  - id: python-taint-code-injection
    mode: taint
    pattern-sources:
      - pattern: request.args.get(...)
      - pattern: request.json.get(...)
    pattern-sinks:
      - pattern: eval($CODE)
      - pattern: exec($CODE)
      - pattern: compile($CODE, ...)
    message: Code injection via eval/exec
    languages: [python]
    severity: ERROR
    metadata:
      cwe: CWE-95

  # JavaScript taint rules
  - id: js-taint-xss
    mode: taint
    pattern-sources:
      - pattern: req.query.$X
      - pattern: req.body.$X
      - pattern: location.search
    pattern-sinks:
      - pattern: $EL.innerHTML = $DATA
      - pattern: document.write($DATA)
      - pattern: dangerouslySetInnerHTML={...}
    message: XSS - user input flows to DOM manipulation
    languages: [javascript, typescript]
    severity: ERROR
    metadata:
      cwe: CWE-79

  - id: js-taint-code-injection
    mode: taint
    pattern-sources:
      - pattern: req.query.$X
      - pattern: req.params.$X
    pattern-sinks:
      - pattern: eval($CODE)
      - pattern: Function($CODE)
    message: Code injection via eval/Function
    languages: [javascript, typescript]
    severity: ERROR
    metadata:
      cwe: CWE-95

  # Java taint rules
  - id: java-taint-sql-injection
    mode: taint
    pattern-sources:
      - pattern: request.getParameter(...)
      - pattern: request.getHeader(...)
    pattern-sinks:
      - pattern: $STMT.executeQuery($QUERY)
      - pattern: $STMT.executeUpdate($QUERY)
    message: SQL injection in Java
    languages: [java]
    severity: ERROR
    metadata:
      cwe: CWE-89

  - id: java-taint-command-injection
    mode: taint
    pattern-sources:
      - pattern: request.getParameter(...)
      - pattern: System.getenv(...)
    pattern-sinks:
      - pattern: Runtime.getRuntime().exec($CMD)
      - pattern: new ProcessBuilder($CMD)
    message: Command injection in Java
    languages: [java]
    severity: ERROR
    metadata:
      cwe: CWE-78

  # C/C++ taint rules
  - id: c-taint-buffer-overflow
    mode: taint
    pattern-sources:
      - pattern: getenv(...)
      - pattern: fgets(...)
    pattern-sinks:
      - pattern: strcpy($DST, $SRC)
      - pattern: sprintf($DST, $FMT, ...)
      - pattern: strcat($DST, $SRC)
    message: Buffer overflow - unsafe string operation with tainted input
    languages: [c, cpp]
    severity: ERROR
    metadata:
      cwe: CWE-120

  - id: c-taint-command-injection
    mode: taint
    pattern-sources:
      - pattern: getenv(...)
    pattern-sinks:
      - pattern: system($CMD)
      - pattern: popen($CMD, ...)
    message: Command injection in C/C++
    languages: [c, cpp]
    severity: ERROR
    metadata:
      cwe: CWE-78
"""
        self.semgrep_taint_rules_file = Path("semgrep_taint_rules.yml")
        with open(self.semgrep_taint_rules_file, 'w') as f:
            f.write(rules_content)
        logger.info(f"Created Semgrep taint rules: {self.semgrep_taint_rules_file}")

    def _init_database_connection(self):
        """Connect to PostgreSQL CVE/CWE database."""
        try:
            self.db_conn = psycopg2.connect(
                host=self.db_config["host"],
                port=self.db_config["port"],
                database=self.db_config["database"],
                user=self.db_config["user"],
                password=self.db_config["password"],
            )
            logger.info("Connected to PostgreSQL CVE/CWE database")
        except Exception as e:
            logger.warning(f"Database connection failed: {e}")
            logger.warning("Continuing WITHOUT CVE enrichment")
            self.db_conn = None

    def _init_ai_model(self):
        """Load Qwen model."""
        try:
            logger.info(f"Loading Qwen model from: {self.model_path}")
            self.qwen_tokenizer = AutoTokenizer.from_pretrained(
                self.model_path,
                trust_remote_code=True,
            )
            self.qwen_model = AutoModelForCausalLM.from_pretrained(
                self.model_path,
                torch_dtype=torch.float16,
                device_map="auto",
                trust_remote_code=True,
            )
            self.device = "cuda" if torch.cuda.is_available() else "cpu"
            logger.info(f"Qwen model loaded on {self.device}")
        except Exception as e:
            logger.error(f"Model initialization failed: {e}")
            raise

    def _init_mappings(self):
        """Initialize language and CWE mappings."""
        self.language_extensions = {
            "Java": [".java"],
            "Python": [".py"],
            "JavaScript": [".js", ".jsx", ".ts", ".tsx"],
            "C": [".c", ".h"],
            "C++": [".cpp", ".cc", ".cxx", ".hpp", ".hxx", ".h++"],
            "PHP": [".php"],
            "C#": [".cs"],
            "Go": [".go"],
            "Ruby": [".rb"],
            "Rust": [".rs"],
        }

        self.cwe_to_vulnerability_name = {
            "CWE-79": "Cross-Site Scripting (XSS)",
            "CWE-89": "SQL Injection",
            "CWE-78": "OS Command Injection",
            "CWE-95": "Code Injection (eval/exec)",
            "CWE-22": "Path Traversal",
            "CWE-120": "Buffer Overflow",
            "CWE-502": "Insecure Deserialization",
            # ... (keep your existing mappings)
        }

        self.cwe_severity_map = {
            "CWE-89": "CRITICAL",
            "CWE-78": "CRITICAL",
            "CWE-95": "CRITICAL",
            "CWE-502": "CRITICAL",
            "CWE-79": "HIGH",
            "CWE-22": "HIGH",
            "CWE-120": "HIGH",
            # ... (keep your existing mappings)
        }

    # ------------------------------------------------------------------
    # Utility helpers
    # ------------------------------------------------------------------
    def clean_macos_artifacts(self, path: str) -> None:
        """Delete __MACOSX and .DS_Store files."""
        removed = 0
        for root, dirs, files in os.walk(path):
            if "__MACOSX" in dirs:
                p = os.path.join(root, "__MACOSX")
                shutil.rmtree(p, ignore_errors=True)
                removed += 1
            for f in files:
                if f == ".DS_Store":
                    p = os.path.join(root, f)
                    try:
                        os.remove(p)
                        removed += 1
                    except Exception:
                        pass
        if removed:
            logger.info(f"Cleaned {removed} macOS artifacts")

    def detect_language(self, file_path: str) -> str:
        ext = Path(file_path).suffix.lower()
        for lang, exts in self.language_extensions.items():
            if ext in exts:
                return lang
        return "Unknown"

    def extract_code_snippet(self, file_path: str, line_number: int, context: int = 2) -> str:
        """Extract lines around the finding."""
        try:
            with open(file_path, "r", encoding="utf-8", errors="ignore") as f:
                lines = f.readlines()
            if not lines:
                return ""
            idx = max(0, line_number - 1)
            start = max(0, idx - context)
            end = min(len(lines), idx + context + 1)
            out = []
            for i in range(start, end):
                mark = ">>> " if i == idx else "    "
                out.append(f"{mark}{lines[i].rstrip()}")
            return "\n".join(out)
        except Exception as e:
            return f"[Error reading file: {e}]"

    # ------------------------------------------------------------------
    # Semgrep with Taint Mode
    # ------------------------------------------------------------------
    def run_semgrep_scan(self, target_path: str) -> List[Dict[str, Any]]:
        """Run Semgrep with taint-tracking rules."""
        logger.info(f"Running Semgrep with taint mode on: {target_path}")
        results: List[Dict[str, Any]] = []

        configs = [
            "p/owasp-top-ten",
            "p/cwe-top-25",
            "p/security-audit",
            str(self.semgrep_taint_rules_file),  # Custom taint rules
        ]

        for cfg in configs:
            try:
                cmd = [
                    "semgrep",
                    "--config", cfg,
                    "--json",
                    "--quiet",
                    "--dataflow-traces",  # Enable taint flow traces
                    "--severity=ERROR",
                    "--severity=WARNING",
                    target_path,
                ]
                proc = subprocess.run(
                    cmd,
                    capture_output=True,
                    text=True,
                    timeout=600,
                )
                if proc.returncode not in (0, 1):
                    continue
                data = json.loads(proc.stdout or "{}")
                results.extend(data.get("results", []))
            except subprocess.TimeoutExpired:
                logger.warning(f"Semgrep timeout for config: {cfg}")
            except Exception as e:
                logger.warning(f"Semgrep error for config {cfg}: {e}")

        # Deduplicate
        unique: List[Dict[str, Any]] = []
        seen = set()
        for r in results:
            key = (r.get("path"), r.get("start", {}).get("line"))
            if key not in seen:
                seen.add(key)
                unique.append(r)

        logger.info(f"Semgrep produced {len(unique)} unique findings")
        return unique

    # ------------------------------------------------------------------
    # CWE / CVE enrichment (keep your existing methods)
    # ------------------------------------------------------------------
    def extract_cwe_from_semgrep(self, finding: Dict[str, Any]) -> Optional[str]:
        """Extract CWE from Semgrep metadata."""
        metadata = finding.get("extra", {}).get("metadata", {})
        cwes = metadata.get("cwe", [])
        if isinstance(cwes, list) and cwes:
            return cwes[0]
        if isinstance(cwes, str) and cwes:
            return cwes
        msg = finding.get("extra", {}).get("message", "") or ""
        m = re.search(r"CWE-\d+", msg, re.IGNORECASE)
        if m:
            return m.group(0).upper()
        return None

    def classify_cwe_with_qwen(self, message: str, code_snippet: str) -> str:
        """Use Qwen to classify CWE."""
        try:
            prompt = f"""You are a security expert. Analyze this vulnerability and identify the CWE ID.

Security Finding: {message}
Code:
{code_snippet[:200]}

Provide ONLY the CWE ID (format: CWE-XXX). Examples: CWE-79, CWE-89, CWE-78

CWE ID:"""

            inputs = self.qwen_tokenizer(prompt, return_tensors="pt").to(self.device)
            with torch.no_grad():
                outputs = self.qwen_model.generate(
                    **inputs,
                    max_new_tokens=20,
                    temperature=0.3,
                    do_sample=True,
                    top_p=0.9,
                )

            response = self.qwen_tokenizer.decode(outputs[0], skip_special_tokens=True)
            m = re.search(r"CWE-\d+", response, re.IGNORECASE)
            return m.group(0).upper() if m else "CWE-20"
        except Exception as e:
            logger.warning(f"CWE classification error: {e}")
            return "CWE-20"

    def generate_vulnerability_name(self, message: str, cwe_id: str) -> str:
        """Generate human-readable vuln name."""
        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        if cwe_clean in self.cwe_to_vulnerability_name:
            return self.cwe_to_vulnerability_name[cwe_clean]
        return f"Security Vulnerability ({cwe_clean})"

    def query_cve_database(self, cwe_id: str, language: str = None) -> List[Dict[str, Any]]:
        """Query PostgreSQL for CVEs."""
        if not self.db_conn:
            return []
        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        try:
            with self.db_conn.cursor(cursor_factory=RealDictCursor) as cur:
                query = """
                    SELECT cve_id, description, cvss_base_severity AS severity,
                           cvss_base_score AS cvss_score, published_date
                    FROM cve
                    WHERE %s = ANY(cwe_ids)
                    ORDER BY cvss_base_score DESC NULLS LAST LIMIT 5
                """
                cur.execute(query, [cwe_clean])
                rows = cur.fetchall()
                return [dict(r) for r in rows]
        except Exception as e:
            logger.warning(f"CVE query failed: {e}")
            return []

    def calculate_severity(self, cwe_id: str, cvss_score: Optional[float]) -> str:
        """Calculate severity from CWE and CVSS."""
        cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id
        if cwe_clean in self.cwe_severity_map:
            return self.cwe_severity_map[cwe_clean]
        if cvss_score is not None:
            try:
                s = float(cvss_score)
                if s >= 9.0:
                    return "CRITICAL"
                if s >= 7.0:
                    return "HIGH"
                if s >= 4.0:
                    return "MEDIUM"
                return "LOW"
            except Exception:
                pass
        return "MEDIUM"

    # ------------------------------------------------------------------
    # Enhanced False Positive Filter with Taint Tracking
    # ------------------------------------------------------------------
    def refine_vulnerability(self, v: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """
        Enhanced refinement with taint tracking.
        Drops findings where dangerous functions don't receive tainted input.
        """
        # Basic text filters
        text_fields = []
        for key in ("vulnerability", "ai_explanation", "details", "message", "raw_message"):
            val = v.get(key)
            if isinstance(val, str):
                text_fields.append(val)

        code = v.get("code_snippet") or ""
        text_fields.append(code)
        text_blob = " ".join(text_fields).lower()

        # Hard filter: "Not Vulnerable"
        NEG_PATTERNS = [
            "not vulnerable", "no vulnerable code", "this code is safe",
            "code is already correct and not vulnerable",
        ]
        if any(pat in text_blob for pat in NEG_PATTERNS):
            logger.info(f"Dropping: 'not vulnerable' text in {v.get('file_path')}:{v.get('line_number')}")
            return None

        # ✨ NEW: Taint analysis filter
        file_path = v.get('file_path', '')
        line_num = v.get('line_number', 0)
        
        if file_path and line_num:
            try:
                line_int = int(str(line_num).strip())
                abs_path = file_path if os.path.isabs(file_path) else os.path.join(os.getcwd(), file_path)
                
                if os.path.exists(abs_path):
                    taint_result = self.taint_tracker.analyze_file(abs_path, line_int)
                    
                    # If taint analysis says "not tainted" with high confidence, drop it
                    if taint_result['is_tainted'] is False and taint_result['confidence'] == 'high':
                        logger.info(
                            f"✅ Dropping FP (no tainted data flow): {file_path}:{line_num}\n"
                            f"   Flow: {taint_result['flow']}"
                        )
                        return None
                    
                    # If tainted, enrich the finding
                    if taint_result['is_tainted'] is True:
                        v['taint_flow'] = taint_result['flow']
                        v['taint_confidence'] = taint_result['confidence']
                        logger.info(
                            f"❌ Confirmed tainted flow: {file_path}:{line_num}\n"
                            f"   {taint_result['flow']}"
                        )
                    else:
                        # Uncertain - keep but mark
                        v['taint_flow'] = taint_result['flow']
                        v['taint_confidence'] = taint_result['confidence']
            
            except Exception as e:
                logger.warning(f"Taint analysis failed for {file_path}:{line_num}: {e}")
        
        return v

    # ------------------------------------------------------------------
    # Main Scan
    # ------------------------------------------------------------------
    def scan_path(self, target_path: str) -> pd.DataFrame:
        """Scan target with multi-language taint tracking."""
        target_path = os.path.abspath(target_path)
        logger.info("\n" + "=" * 60)
        logger.info(f"Scanning: {target_path}")
        logger.info("=" * 60)

        self.clean_macos_artifacts(target_path)
        semgrep_findings = self.run_semgrep_scan(target_path)
        records: List[Dict[str, Any]] = []

        for f in semgrep_findings:
            try:
                file_path = f.get("path", "")
                line = f.get("start", {}).get("line", 0)
                message = f.get("extra", {}).get("message", "")

                abs_file = file_path if os.path.isabs(file_path) else os.path.join(target_path, file_path)
                code_snippet = self.extract_code_snippet(abs_file, line)
                language = self.detect_language(file_path)

                cwe_id = self.extract_cwe_from_semgrep(f)
                if not cwe_id:
                    cwe_id = self.classify_cwe_with_qwen(message, code_snippet)

                vuln_name = self.generate_vulnerability_name(message, cwe_id)
                cwe_clean = cwe_id.split(":")[0].strip() if ":" in cwe_id else cwe_id

                cve_entries = self.query_cve_database(cwe_clean, language)
                cve_id = cve_entries[0].get("cve_id", "N/A") if cve_entries else "N/A"
                cvss_score = cve_entries[0].get("cvss_score", None) if cve_entries else None

                severity = self.calculate_severity(cwe_clean, cvss_score)

                record = {
                    "sno": len(records) + 1,
                    "primary_language": language,
                    "vulnerability": vuln_name,
                    "cve_id": cve_id,
                    "severity": severity,
                    "cwe_id": cwe_clean,
                    "file_path": file_path,
                    "line_number": str(line),
                    "code_snippet": code_snippet[:500],
                    "taint_flow": "",
                    "taint_confidence": "",
                }

                record = self.refine_vulnerability(record)
                if record:
                    records.append(record)

            except Exception as e:
                logger.warning(f"Error processing finding: {e}")
                continue

        df = pd.DataFrame(records)
        if not df.empty:
            severity_order = {"CRITICAL": 0, "HIGH": 1, "MEDIUM": 2, "LOW": 3}
            df["severity_rank"] = df["severity"].map(severity_order).fillna(4)
            df = df.sort_values("severity_rank").drop(columns=["severity_rank"])
            df["sno"] = range(1, len(df) + 1)

        logger.info(f"\n✅ Final findings after taint-based refinement: {len(df)}")
        if not df.empty:
            for sev, count in df["severity"].value_counts().items():
                logger.info(f"  {sev}: {count}")

        return df

    def __del__(self):
        try:
            if hasattr(self, "db_conn") and self.db_conn:
                self.db_conn.close()
            if hasattr(self, "semgrep_taint_rules_file") and self.semgrep_taint_rules_file.exists():
                self.semgrep_taint_rules_file.unlink()
        except Exception:
            pass


# ----------------------------------------------------------------------
# CLI
# ----------------------------------------------------------------------
def main():
    parser = argparse.ArgumentParser(description="FOSS-CHERUB v2.0 - Multi-language Taint Tracking Scanner")
    parser.add_argument("--target", required=True, help="Path to scan")
    parser.add_argument("--db-host", default="foss-cherub-db")
    parser.add_argument("--db-port", type=int, default=5432)
    parser.add_argument("--db-name", default="foss_cherub")
    parser.add_argument("--db-user", default="postgres")
    parser.add_argument("--db-pass", default="foss_cherub_2024")
    parser.add_argument("--model-path", required=True, help="Path to Qwen model")
    parser.add_argument("--out", default=None, help="Output CSV")

    args = parser.parse_args()

    if not os.path.exists(args.target):
        raise SystemExit(f"Target does not exist: {args.target}")

    db_config = {
        "host": args.db_host,
        "port": args.db_port,
        "database": args.db_name,
        "user": args.db_user,
        "password": args.db_pass,
    }

    scanner = FOSSCHERUBScanner(db_config, args.model_path)
    df = scanner.scan_path(args.target)

    if df.empty:
        print("✅ No vulnerabilities found (or all were false positives)")
        return

    ts = datetime.now().strftime("%Y%m%d_%H%M%S")
    out_file = args.out or f"foss_cherub_results_{ts}.csv"
    df.to_csv(out_file, index=False)
    print(f"\n✅ Scan complete. Results: {out_file}\n")


if __name__ == "__main__":
    main()
