#!/usr/bin/env python3
import sqlite3
import json
from datetime import datetime
import os

# Use SQLite for testing (no Docker needed)
DB_PATH = "/workspace/vulnerability-detection-tool/db-test/test.db"

def init_sqlite_db():
    """Initialize SQLite database with tables"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Create scans table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                repo_url TEXT,
                scan_name TEXT,
                status TEXT DEFAULT 'running',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP,
                findings_count INTEGER DEFAULT 0
            );
        """)
        
        # Create findings table
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS findings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT,
                file_path TEXT,
                line_number INTEGER,
                severity TEXT,
                cwe_id TEXT,
                description TEXT,
                code_snippet TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans(scan_id)
            );
        """)
        
        conn.commit()
        conn.close()
        print("✓ SQLite database initialized")
        return True
    except Exception as e:
        print(f"✗ Database init failed: {e}")
        return False

def test_sqlite_operations():
    """Test SQLite database operations"""
    try:
        conn = sqlite3.connect(DB_PATH)
        cursor = conn.cursor()
        
        # Insert test scan
        cursor.execute("""
            INSERT OR REPLACE INTO scans (scan_id, repo_url, scan_name, status)
            VALUES (?, ?, ?, ?)
        """, ('test-scan-456', 'https://github.com/test/repo', 'SQLite Test', 'running'))
        
        # Insert test finding
        cursor.execute("""
            INSERT INTO findings (scan_id, file_path, line_number, severity, cwe_id, description, code_snippet)
            VALUES (?, ?, ?, ?, ?, ?, ?)
        """, ('test-scan-456', '/test/file.py', 42, 'HIGH', 'CWE-89', 'SQL Injection', 'SELECT * FROM users'))
        
        # Query data
        cursor.execute("""
            SELECT s.scan_id, s.repo_url, s.status, COUNT(f.id) as findings_count
            FROM scans s
            LEFT JOIN findings f ON s.scan_id = f.scan_id
            WHERE s.scan_id = ?
            GROUP BY s.scan_id, s.repo_url, s.status
        """, ('test-scan-456',))
        
        result = cursor.fetchone()
        if result:
            print(f"✓ SQLite operations successful: {result}")
        
        conn.commit()
        conn.close()
        return True
    except Exception as e:
        print(f"✗ SQLite operations failed: {e}")
        return False

def create_db_adapter():
    """Create a database adapter that works with both SQLite and PostgreSQL"""
    adapter_code = '''
import sqlite3
import psycopg2
from typing import Optional, List, Dict, Any
import os

class DatabaseAdapter:
    def __init__(self, use_sqlite=False):
        self.use_sqlite = use_sqlite
        if use_sqlite:
            self.db_path = "/workspace/vulnerability-detection-tool/foss_cherub.db"
            self._init_sqlite()
        else:
            self.pg_config = {
                'host': 'localhost',
                'port': 5432,
                'database': 'foss_cherub',
                'user': 'postgres',
                'password': 'foss_cherub_2024'
            }
    
    def _init_sqlite(self):
        """Initialize SQLite database"""
        conn = sqlite3.connect(self.db_path)
        cursor = conn.cursor()
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS scans (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT UNIQUE NOT NULL,
                repo_url TEXT,
                scan_name TEXT,
                status TEXT DEFAULT 'running',
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                completed_at TIMESTAMP,
                findings_count INTEGER DEFAULT 0
            );
        """)
        
        cursor.execute("""
            CREATE TABLE IF NOT EXISTS findings (
                id INTEGER PRIMARY KEY AUTOINCREMENT,
                scan_id TEXT,
                file_path TEXT,
                line_number INTEGER,
                severity TEXT,
                cwe_id TEXT,
                description TEXT,
                code_snippet TEXT,
                created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
                FOREIGN KEY (scan_id) REFERENCES scans(scan_id)
            );
        """)
        
        conn.commit()
        conn.close()
    
    def get_connection(self):
        """Get database connection"""
        if self.use_sqlite:
            return sqlite3.connect(self.db_path)
        else:
            return psycopg2.connect(**self.pg_config)
    
    def insert_scan(self, scan_id: str, repo_url: str, scan_name: str, status: str = 'running'):
        """Insert or update scan record"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        if self.use_sqlite:
            cursor.execute("""
                INSERT OR REPLACE INTO scans (scan_id, repo_url, scan_name, status)
                VALUES (?, ?, ?, ?)
            """, (scan_id, repo_url, scan_name, status))
        else:
            cursor.execute("""
                INSERT INTO scans (scan_id, repo_url, scan_name, status)
                VALUES (%s, %s, %s, %s)
                ON CONFLICT (scan_id) DO UPDATE SET
                repo_url = EXCLUDED.repo_url,
                scan_name = EXCLUDED.scan_name,
                status = EXCLUDED.status;
            """, (scan_id, repo_url, scan_name, status))
        
        conn.commit()
        cursor.close()
        conn.close()
    
    def insert_finding(self, scan_id: str, file_path: str, line_number: int, 
                      severity: str, cwe_id: str, description: str, code_snippet: str):
        """Insert finding record"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        if self.use_sqlite:
            cursor.execute("""
                INSERT INTO findings (scan_id, file_path, line_number, severity, cwe_id, description, code_snippet)
                VALUES (?, ?, ?, ?, ?, ?, ?)
            """, (scan_id, file_path, line_number, severity, cwe_id, description, code_snippet))
        else:
            cursor.execute("""
                INSERT INTO findings (scan_id, file_path, line_number, severity, cwe_id, description, code_snippet)
                VALUES (%s, %s, %s, %s, %s, %s, %s)
            """, (scan_id, file_path, line_number, severity, cwe_id, description, code_snippet))
        
        conn.commit()
        cursor.close()
        conn.close()
    
    def get_scan(self, scan_id: str) -> Optional[Dict[str, Any]]:
        """Get scan with findings count"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT s.scan_id, s.repo_url, s.scan_name, s.status, s.created_at, COUNT(f.id) as findings_count
            FROM scans s
            LEFT JOIN findings f ON s.scan_id = f.scan_id
            WHERE s.scan_id = ?
            GROUP BY s.scan_id, s.repo_url, s.scan_name, s.status, s.created_at
        """ if self.use_sqlite else """
            SELECT s.scan_id, s.repo_url, s.scan_name, s.status, s.created_at, COUNT(f.id) as findings_count
            FROM scans s
            LEFT JOIN findings f ON s.scan_id = f.scan_id
            WHERE s.scan_id = %s
            GROUP BY s.scan_id, s.repo_url, s.scan_name, s.status, s.created_at
        """, (scan_id,))
        
        result = cursor.fetchone()
        cursor.close()
        conn.close()
        
        if result:
            return {
                'scan_id': result[0],
                'repo_url': result[1],
                'scan_name': result[2],
                'status': result[3],
                'created_at': result[4],
                'findings_count': result[5]
            }
        return None
    
    def get_findings(self, scan_id: str) -> List[Dict[str, Any]]:
        """Get all findings for a scan"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        cursor.execute("""
            SELECT file_path, line_number, severity, cwe_id, description, code_snippet
            FROM findings
            WHERE scan_id = ?
        """ if self.use_sqlite else """
            SELECT file_path, line_number, severity, cwe_id, description, code_snippet
            FROM findings
            WHERE scan_id = %s
        """, (scan_id,))
        
        results = cursor.fetchall()
        cursor.close()
        conn.close()
        
        return [
            {
                'file_path': row[0],
                'line_number': row[1],
                'severity': row[2],
                'cwe_id': row[3],
                'description': row[4],
                'code_snippet': row[5]
            }
            for row in results
        ]
    
    def update_scan_status(self, scan_id: str, status: str):
        """Update scan status"""
        conn = self.get_connection()
        cursor = conn.cursor()
        
        if self.use_sqlite:
            cursor.execute("UPDATE scans SET status = ? WHERE scan_id = ?", (status, scan_id))
        else:
            cursor.execute("UPDATE scans SET status = %s WHERE scan_id = %s", (status, scan_id))
        
        conn.commit()
        cursor.close()
        conn.close()
'''
    
    with open('/workspace/vulnerability-detection-tool/db_adapter.py', 'w') as f:
        f.write(adapter_code)
    
    print("✓ Database adapter created")

if __name__ == "__main__":
    print("=== SQLite Database Test ===")
    
    # Clean up old database
    if os.path.exists(DB_PATH):
        os.remove(DB_PATH)
    
    # Run tests
    if init_sqlite_db() and test_sqlite_operations():
        print("✓ All SQLite tests passed")
        create_db_adapter()
        print("✓ Database adapter ready for integration")
    else:
        print("✗ SQLite tests failed")