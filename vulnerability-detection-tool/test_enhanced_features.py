#!/usr/bin/env python3
"""
Test script for enhanced FOSS-CHERUB features:
- Code quality improvements
- Safer coding alternatives  
- Enhanced AST analysis
- Comprehensive findings
"""

import os
import tempfile
import json
from pathlib import Path

# Test vulnerable code samples
TEST_SAMPLES = {
    "sql_injection.py": '''
import sqlite3
from flask import Flask, request

app = Flask(__name__)

@app.route('/login', methods=['POST'])
def login():
    username = request.form['username']
    password = request.form['password']
    
    # Vulnerable SQL query construction
    query = f"SELECT * FROM users WHERE username='{username}' AND password='{password}'"
    
    conn = sqlite3.connect('users.db')
    cursor = conn.cursor()
    cursor.execute(query)  # SQL Injection vulnerability
    result = cursor.fetchone()
    
    if result:
        return "Login successful"
    return "Login failed"
''',
    
    "code_injection.py": '''
import os
from flask import Flask, request

app = Flask(__name__)

@app.route('/eval', methods=['POST'])
def evaluate_code():
    user_code = request.form['code']
    
    # Dangerous code execution
    result = eval(user_code)  # Code injection vulnerability
    
    return str(result)

@app.route('/system', methods=['POST'])  
def run_command():
    cmd = request.form['command']
    
    # Command injection vulnerability
    os.system(cmd)  # Dangerous system call
    
    return "Command executed"
''',

    "weak_crypto.py": '''
import hashlib
import secrets

def hash_password(password):
    # Weak cryptographic hash
    return hashlib.md5(password.encode()).hexdigest()  # Weak crypto

def generate_token():
    # Insecure random generation
    import random
    return str(random.randint(1000, 9999))  # Weak randomness

def store_secret():
    # Hardcoded credentials
    api_key = "sk-1234567890abcdef"  # Hardcoded secret
    db_password = "admin123"  # Hardcoded password
    
    return api_key, db_password
'''
}

def create_test_files():
    """Create test files with vulnerable code"""
    test_dir = tempfile.mkdtemp(prefix="foss_cherub_test_")
    print(f"Created test directory: {test_dir}")
    
    for filename, content in TEST_SAMPLES.items():
        file_path = Path(test_dir) / filename
        with open(file_path, 'w') as f:
            f.write(content)
        print(f"Created test file: {file_path}")
    
    return test_dir

def test_enhanced_scanner():
    """Test the enhanced scanner features"""
    try:
        from foss_scanner import FOSSCHERUBScanner
        
        # Create test files
        test_dir = create_test_files()
        
        # Initialize scanner
        model_path = "/workspace/vulnerability-detection-tool/data_processing/merged_model"
        if not os.path.exists(model_path):
            print(f"Warning: Model path {model_path} not found. Using mock analysis.")
            return
            
        scanner = FOSSCHERUBScanner(None, model_path)
        
        # Run scan
        print(f"\nüîç Scanning test directory: {test_dir}")
        df = scanner.scan_path(test_dir)
        
        if df.empty:
            print("‚ùå No findings detected")
            return
            
        print(f"\n‚úÖ Found {len(df)} vulnerabilities")
        
        # Test enhanced features
        for idx, finding in df.iterrows():
            print(f"\n--- Finding {idx + 1} ---")
            print(f"Vulnerability: {finding.get('vulnerability', 'N/A')}")
            print(f"CWE: {finding.get('cwe_id', 'N/A')}")
            print(f"Severity: {finding.get('severity', 'N/A')}")
            print(f"File: {finding.get('file_path', 'N/A')}")
            print(f"Line: {finding.get('line_number', 'N/A')}")
            
            # Test enhanced fields
            if finding.get('code_quality_improvements'):
                print(f"‚ú® Code Quality Improvements: Available")
            if finding.get('safer_coding_alternatives'):
                print(f"üîí Safer Coding Alternatives: Available")
            if finding.get('ast_structure_analysis'):
                print(f"üå≥ AST Structure Analysis: Available")
            if finding.get('security_best_practices'):
                print(f"üõ°Ô∏è Security Best Practices: Available")
            if finding.get('performance_impact'):
                print(f"‚ö° Performance Impact: Available")
            if finding.get('vulnerability_patterns'):
                patterns = finding.get('vulnerability_patterns', [])
                print(f"üéØ Vulnerability Patterns: {', '.join(patterns) if patterns else 'None'}")
            if finding.get('remediation_priority'):
                print(f"üö® Remediation Priority: {finding.get('remediation_priority')}")
            if finding.get('code_complexity_metrics'):
                metrics = finding.get('code_complexity_metrics', {})
                if metrics:
                    print(f"üìä Complexity Metrics: {json.dumps(metrics, indent=2)}")
            if finding.get('compliance_violations'):
                violations = finding.get('compliance_violations', [])
                print(f"‚öñÔ∏è Compliance Violations: {', '.join(violations) if violations else 'None'}")
            if finding.get('business_impact'):
                print(f"üíº Business Impact: Available")
                
        # Cleanup
        import shutil
        shutil.rmtree(test_dir, ignore_errors=True)
        print(f"\nüßπ Cleaned up test directory: {test_dir}")
        
    except Exception as e:
        print(f"‚ùå Test failed: {e}")
        import traceback
        traceback.print_exc()

def test_api_integration():
    """Test API integration with enhanced features"""
    try:
        import requests
        import time
        
        # Test API endpoints
        base_url = "http://localhost:8082"
        
        # Check if API is running
        try:
            response = requests.get(f"{base_url}/api/health", timeout=5)
            if response.status_code != 200:
                print("‚ùå API not running. Start with: python backend/api.py")
                return
        except requests.exceptions.RequestException:
            print("‚ùå API not accessible. Start with: python backend/api.py")
            return
            
        print("‚úÖ API is running")
        
        # Create a test scan
        test_dir = create_test_files()
        
        # Upload test files (simplified - would need actual file upload)
        print("üì§ Testing enhanced API features...")
        
        # Test enhanced endpoints
        endpoints_to_test = [
            "/api/analysis/sections",
            "/api/cache/status",
            "/api/incremental/status"
        ]
        
        for endpoint in endpoints_to_test:
            try:
                response = requests.get(f"{base_url}{endpoint}", timeout=10)
                if response.status_code == 200:
                    print(f"‚úÖ {endpoint}: OK")
                else:
                    print(f"‚ö†Ô∏è {endpoint}: Status {response.status_code}")
            except Exception as e:
                print(f"‚ùå {endpoint}: Error - {e}")
        
        # Cleanup
        import shutil
        shutil.rmtree(test_dir, ignore_errors=True)
        
    except Exception as e:
        print(f"‚ùå API test failed: {e}")

def main():
    """Run all tests"""
    print("üöÄ Testing Enhanced FOSS-CHERUB Features")
    print("=" * 50)
    
    print("\n1. Testing Enhanced Scanner...")
    test_enhanced_scanner()
    
    print("\n2. Testing API Integration...")
    test_api_integration()
    
    print("\n‚úÖ Enhanced features testing completed!")
    print("\nNew Features Added:")
    print("- Code quality improvements and suggestions")
    print("- Safer coding alternatives and patterns")
    print("- Enhanced AST tree analysis with vulnerability nodes")
    print("- Comprehensive findings with business impact")
    print("- Code complexity metrics and maintainability scores")
    print("- Compliance violation detection (OWASP, PCI DSS, SOC 2)")
    print("- Remediation priority calculation")
    print("- Performance impact analysis")
    print("- Vulnerability pattern extraction")

if __name__ == "__main__":
    main()